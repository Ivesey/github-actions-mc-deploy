name: "Infrastructure as Code pipeline"

on:
  workflow_dispatch:
  push:
    branches:
    - main
    paths:
    - tf/**
    

env:
  # verbosity setting for Terraform logs
  TF_LOG: INFO

  # S3 bucket for the Terraform state
  BUCKET_TF_STATE: ${{ secrets.BUCKET_TF_STATE}}
  AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
  AWS_REGION: eu-west-2

permissions:
  id-token: write
  contents: read

jobs:
  infrastructure:
    name: Create or update EKS and AKS clusters
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: ./tf

    steps:
      - name: Checkout the repository to the runner
        id: checkout
        uses: actions/checkout@v2
 
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4.3.1
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          role-session-name: github-actions-demo
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure Azure credentials
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
    
      - name: Terraform init
        id: init
        run: terraform init -backend-config="bucket=$BUCKET_TF_STATE"
 
      - name: Terraform format
        id: fmt
        run: terraform fmt -check
    
      - name: Terraform validate
        id: validate
        run: terraform validate
 
      - name: Terraform plan
        id: plan
        run: |
          terraform plan -no-color -input=false -refresh=false \
            -var eks_cluster_name=${{ vars.EKS_CLUSTER_NAME }} \
            -var aks_cluster_name=${{ vars.AKS_CLUSTER_NAME }} \
            -var resource_group_name=${{ vars.RESOURCE_GROUP_NAME }}
    
      - name: Terraform Apply
        run: |
          terraform apply -auto-approve -input=false \
            -var eks_cluster_name=${{ vars.EKS_CLUSTER_NAME }} \
            -var aks_cluster_name=${{ vars.AKS_CLUSTER_NAME }} \
            -var resource_group_name=${{ vars.RESOURCE_GROUP_NAME }}

      - name: Setup kubectl
        id: install-kubectl
        uses: azure/setup-kubectl@v3

      - name: Set AKS context
        id: set-context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ vars.RESOURCE_GROUP_NAME }}
          cluster-name: ${{ vars.AKS_CLUSTER_NAME }}

      - name: Ensure Azure namespace
        id: create-ns
        run: |
          if [[ $(kubectl get namespace gha-demo-azure --ignore-not-found | wc -l) -eq 0 ]]; then
            echo "create=true" >> $GITHUB_OUTPUT
            kubectl create namespace gha-demo-azure
          fi

      - name: Apply Azure Manifest
        id: deploy-aks
        if: ${{ steps.create-ns.outputs.create == 'true' }}
        run: |
          kubectl apply --namespace gha-demo-azure \
            -f ../base-manifests/app-manifest.yaml

      - name: Output load balancer IP
        id: aks-lb
        run: |
          kubectl wait \
            --for=jsonpath='{.status.loadBalancer.ingress}' \
            service/main-app \
            --namespace gha-demo-azure
          AKS_LB=$(kubectl get service/main-app \
            --namespace=gha-demo-azure \
            --output jsonpath="{.status.loadBalancer.ingress[0].ip}")
          echo "aks-lb=$AKS_LB" >> $GITHUB_OUTPUT

      - name: Set EKS context
        id: set-eks-context
        run: |
          aws eks update-kubeconfig \
            --name ${{ vars.EKS_CLUSTER_NAME }} \
            --region ${{ env.AWS_REGION }}

      - name: Ensure AWS namespace
        id: create-eks-ns
        run: |
          if [[ $(kubectl get namespace gha-demo-aws --ignore-not-found | wc -l) -eq 0 ]]; then
            echo "create=true" >> $GITHUB_OUTPUT
            kubectl create namespace gha-demo-aws
          fi

      - name: Apply AWS Manifest
        id: deploy-eks
        if: ${{ steps.create-eks-ns.outputs.create == 'true' }}
        run: |
          sed 's/-azure-/-aws-/g' ../base-manifests/app-manifest.yaml \
            | kubectl apply --namespace gha-demo-aws -f -
        # NOTE: we should probably be using Kustomize, GitOps and Helm here,
        #       but this demo is already very long!

      - name: Output EKS LB address
        id: eks-lb
        run: |
          kubectl wait \
            --for=jsonpath='{.status.loadBalancer.ingress}' \
            service/main-app \
            --namespace gha-demo-aws
          AWS_LB=$(kubectl get service/main-app \
            --namespace=gha-demo-aws \
            --output jsonpath="{.status.loadBalancer.ingress[0].hostname}")
          echo "eks-lb=$AWS_LB" >> $GITHUB_OUTPUT

      - name: Output LB addresses
        run: |
          echo AKS LB address: http://${{ steps.aks-lb.outputs.aks-lb }}
          echo EKS LB address: http://${{ steps.eks-lb.outputs.eks-lb }}